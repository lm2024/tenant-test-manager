# 数据同步与缓存策略详细方案

## 1. 数据一致性挑战

### 1.1 当前问题
- MySQL与ES数据不一致
- 缓存与数据库数据不同步
- 高并发下数据竞争
- 分布式事务复杂

### 1.2 一致性级别选择
- **强一致性**：关键业务数据（用户信息、权限等）
- **最终一致性**：搜索数据、统计数据
- **弱一致性**：日志数据、监控数据

## 2. MySQL到ES同步方案

### 2.1 推荐方案：Canal + Redis Stream
```
MySQL Binlog -> Canal -> Redis Stream -> ES Consumer -> Elasticsearch
```

**优势**：
- 基于binlog，数据不丢失
- 异步处理，性能好
- 支持多消费者
- 易于监控和运维

### 2.2 实现架构
```java
// Canal配置
@Configuration
public class CanalConfiguration {
    
    @Bean
    public CanalConnector canalConnector() {
        return CanalConnectors.newSingleConnector(
            new InetSocketAddress("127.0.0.1", 11111),
            "example", "", ""
        );
    }
}

// 数据同步服务
@Service
@Slf4j
public class DataSyncService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    public void syncToES(String database, String table, List<CanalEntry.RowData> rowDataList) {
        for (CanalEntry.RowData rowData : rowDataList) {
            SyncMessage message = buildSyncMessage(database, table, rowData);
            // 发送到Redis Stream
            redisTemplate.opsForStream().add("sync:stream", message.toMap());
        }
    }
}
```

### 2.3 ES消费者实现
```java
@Component
@Slf4j
public class ESSyncConsumer {
    
    @Autowired
    private ElasticsearchRestTemplate esTemplate;
    
    @StreamListener("sync:stream")
    public void handleSyncMessage(SyncMessage message) {
        try {
            switch (message.getOperation()) {
                case INSERT:
                case UPDATE:
                    esTemplate.save(message.getData());
                    break;
                case DELETE:
                    esTemplate.delete(message.getId(), message.getIndexName());
                    break;
            }
            log.info("ES同步成功: {}", message);
        } catch (Exception e) {
            log.error("ES同步失败: {}", message, e);
            // 发送到死信队列
            sendToDeadLetterQueue(message);
        }
    }
}
```

## 3. 多级缓存架构

### 3.1 缓存层次设计
```
应用层缓存 (Caffeine) -> Redis缓存 -> 数据库
```

### 3.2 缓存策略
```java
@Service
public class TenantCacheService {
    
    // L1缓存：本地缓存
    private final Cache<String, Object> localCache = Caffeine.newBuilder()
        .maximumSize(1000)
        .expireAfterWrite(5, TimeUnit.MINUTES)
        .build();
    
    // L2缓存：Redis缓存
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    public <T> T get(String key, Class<T> type, Supplier<T> loader) {
        // 1. 先查本地缓存
        T value = (T) localCache.getIfPresent(key);
        if (value != null) {
            return value;
        }
        
        // 2. 查Redis缓存
        value = (T) redisTemplate.opsForValue().get(key);
        if (value != null) {
            localCache.put(key, value);
            return value;
        }
        
        // 3. 查数据库并缓存
        value = loader.get();
        if (value != null) {
            redisTemplate.opsForValue().set(key, value, Duration.ofMinutes(30));
            localCache.put(key, value);
        }
        
        return value;
    }
}
```

## 4. 分布式锁方案

### 4.1 Redisson分布式锁
```java
@Service
public class DistributedLockService {
    
    @Autowired
    private RedissonClient redissonClient;
    
    public <T> T executeWithLock(String lockKey, Supplier<T> supplier) {
        RLock lock = redissonClient.getLock(lockKey);
        try {
            if (lock.tryLock(10, 30, TimeUnit.SECONDS)) {
                return supplier.get();
            } else {
                throw new RuntimeException("获取锁失败: " + lockKey);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException("锁等待被中断", e);
        } finally {
            if (lock.isHeldByCurrentThread()) {
                lock.unlock();
            }
        }
    }
}
```

## 5. 数据一致性校验

### 5.1 定时校验任务
```java
@Component
@Slf4j
public class DataConsistencyChecker {
    
    @Scheduled(cron = "0 0 2 * * ?") // 每天凌晨2点执行
    public void checkConsistency() {
        List<String> tenantIds = getTenantIds();
        
        for (String tenantId : tenantIds) {
            checkTenantDataConsistency(tenantId);
        }
    }
    
    private void checkTenantDataConsistency(String tenantId) {
        // 1. 检查MySQL与ES数据一致性
        checkMySQLESConsistency(tenantId);
        
        // 2. 检查缓存与数据库一致性
        checkCacheDBConsistency(tenantId);
        
        // 3. 生成一致性报告
        generateConsistencyReport(tenantId);
    }
}
```

### 5.2 数据修复机制
```java
@Service
public class DataRepairService {
    
    public void repairInconsistentData(String tenantId, String dataType) {
        switch (dataType) {
            case "mysql_es":
                repairMySQLESInconsistency(tenantId);
                break;
            case "cache_db":
                repairCacheDBInconsistency(tenantId);
                break;
        }
    }
    
    private void repairMySQLESInconsistency(String tenantId) {
        // 从MySQL重新同步到ES
        List<Object> mysqlData = getMySQLData(tenantId);
        for (Object data : mysqlData) {
            syncToES(data);
        }
    }
}
```

## 6. 监控与告警

### 6.1 同步延迟监控
```java
@Component
public class SyncMonitor {
    
    private final MeterRegistry meterRegistry;
    private final Timer syncTimer;
    private final Counter syncErrorCounter;
    
    public SyncMonitor(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.syncTimer = Timer.builder("data.sync.duration")
            .description("数据同步耗时")
            .register(meterRegistry);
        this.syncErrorCounter = Counter.builder("data.sync.error")
            .description("数据同步错误次数")
            .register(meterRegistry);
    }
    
    public void recordSyncTime(Duration duration) {
        syncTimer.record(duration);
    }
    
    public void recordSyncError() {
        syncErrorCounter.increment();
    }
}
```

### 6.2 告警规则
```yaml
# Prometheus告警规则
groups:
  - name: data_sync_alerts
    rules:
      - alert: DataSyncDelay
        expr: data_sync_delay_seconds > 300
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "数据同步延迟超过5分钟"
          
      - alert: DataSyncError
        expr: increase(data_sync_error_total[5m]) > 10
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "数据同步错误频率过高"
```

## 7. 性能优化建议

### 7.1 批量处理
- ES批量索引操作
- Redis pipeline操作
- 数据库批量更新

### 7.2 异步处理
- 使用CompletableFuture
- 线程池隔离
- 背压控制

### 7.3 资源隔离
- 不同租户使用不同的线程池
- 限流和熔断
- 资源配额管理

这个方案能够很好地解决你提到的一致性问题，同时保证高性能。你觉得这个方案如何？